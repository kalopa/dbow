#ident "$Id$"

/*
 * $Id$
 *
 * Copyright (c) 2003, Kalopa Media Limited.  All rights reserved.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * It is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this product; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,
 * USA.
 *
 * THIS SOFTWARE IS PROVIDED BY KALOPA MEDIA LIMITED "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL KALOPA MEDIA LIMITED BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ABSTRACT
 *
 * $Log$
 * Revision 1.2  2003/10/14 14:10:56  dtynan
 * Some fixes for SQL and C, as well as 'dnl' lines in the M4 templates to
 * reduce blank lines in the output.
 *
 * Revision 1.1  2003/10/14 13:00:26  dtynan
 * Major revision of the DBOW code to use M4 as a back-end instead of
 * hard-coding the output.
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "dbowint.h"

#define M4	"/usr/bin/m4"

#define BTYPE_FILL	0
#define BTYPE_ALLOC	1
#define BTYPE_FREE	2
#define BTYPE_INSERT	3
#define NBASETYPES	4

char	*basetype[NBASETYPES] = {
	"FILL", "ALLOC", "FREE", "INSERT"
};

char	*codetype[NTYPES] = {
	"TYPE_TINYINT", "TYPE_SMALLINT", "TYPE_MEDINT", "TYPE_INT",
	"TYPE_BIGINT", "TYPE_FLOAT", "TYPE_DOUBLE", "TYPE_NUMERIC", "TYPE_DATE",
	"TYPE_TIME", "TYPE_DATETIME", "TYPE_TSTAMP", "TYPE_YEAR", "TYPE_CHAR",
	"TYPE_VARCHAR", "TYPE_TINYBLOB", "TYPE_TINYTEXT", "TYPE_BLOB",
	"TYPE_TEXT", "TYPE_MEDBLOB", "TYPE_MEDTEXT", "TYPE_LONGBLOB",
	"TYPE_LONGTEXT", "TYPE_ENUM", "TYPE_SET"
};

/*
 *
 */
static void
set1field(char *label, char *val1, FILE *fp)
{
	fprintf(fp, "%s(`%s')\n", label, val1);
}

/*
 *
 */
static void
set2field(char *label, char *val1, char *val2, FILE *fp)
{
	fprintf(fp, "%s(`%s',`%s')\n", label, val1, val2);
}

/*
 *
 */
void
genprolog(char *fname, FILE *fp)
{
	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE)
		return;
	fprintf(fp, "dnl\ndnl Intermediate M4 file produced by DBOW from ");
	fprintf(fp, "\"%s\"\ndnl Do not edit this file.  Combine it ", fname);
	fprintf(fp, "with the appropriate DBOW M4 file\ndnl to produce the ");
	fprintf(fp, "appropriate output.\ndnl\n");
	set1field("FILE_PROLOG", fname, fp);
}

/*
 *
 */
void
gensync(char *fname, int lineno, FILE *fp)
{
	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (nflag || active->cdtype == CDT_DBASE)
		return;
	fprintf(fp, "LSYNC(%d, `%s')\n", lineno, fname);
}

/*
 *
 */
void
geninclude(char *fname, FILE *fp)
{
	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE)
		return;
	set1field("INCLUDE", fname, fp);
}

/*
 *
 */
void
genexclude(char *fname, int where, FILE *fp)
{
	char *cp, *bufp;

	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE)
		return;
	if (fname == NULL || (bufp = strdup(fname)) == NULL)
		return;
	for (cp = bufp; *cp; cp++) {
		if (*cp == '.')
			*cp = '_';
		else if (islower(*cp))
			*cp = toupper(*cp);
	}
	if (where == 0)
		set1field("EXCLUDE_INC_PROLOG", bufp, fp);
	else
		set1field("EXCLUDE_INC_EPILOG", bufp, fp);
}

/*
 *
 */
void
genstr(struct table *tp, FILE *fp)
{
	struct column *cp;

	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE) {
		generatesql(tp, fp);
		return;
	}
	set1field("STR_PROLOG", tp->name, fp);
	for (cp = tp->chead; cp != NULL; cp = cp->next) {
		fprintf(fp, "STR_%sELEMENT", cp->flags&FLAG_UNSIGNED ? "U" : "");
		fprintf(fp, "(S%s", codetype[cp->type]);
		fprintf(fp, "(`%s'", cp->name);
		fprintf(fp, ",%d))\n", cp->length);
	}
	set1field("STR_EPILOG", tp->name, fp);
	set1field("PROTO_PROLOG", tp->name, fp);
	set2field("PROTO_INSERT", tp->name, tp->ifname, fp);
	for (cp = tp->chead; cp != NULL; cp = cp->next) {
		if (cp->dfname != NULL) {
			fprintf(fp, "PROTO_DELETE(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->dfname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0))\n", cp->name);
		}
		if (cp->sfname != NULL) {
			fprintf(fp, "PROTO_SEARCH(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->sfname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0))\n", cp->name);
		}
		if (cp->ufname != NULL) {
			fprintf(fp, "PROTO_UPDATE(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->ufname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0))\n", cp->name);
		}
	}
	if (tp->flags & FLAG_DUMP)
		fprintf(fp, "PROTO_DUMP(`%s',`db_dump%s')\n", tp->name, tp->name);
	set1field("PROTO_EPILOG", tp->name, fp);
}

/*
 *
 */
void
gencode(struct table *tp, FILE *fp)
{
	int i, n;
	char *type;
	struct column *cp;

	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE)
		return;
	for (i = 0; i < NBASETYPES; i++) {
		if (i == BTYPE_INSERT)
			set2field("INSERT_PROLOG", tp->name, tp->ifname, fp);
		else
			fprintf(fp, "%s_PROLOG(`%s')\n", basetype[i], tp->name);
		for (n = 0, cp = tp->chead; cp != NULL; n++, cp = cp->next) {
			fprintf(fp, "%s_ELEMENT(", basetype[i]);
			fprintf(fp, "`%s', ", cp->name);
			fprintf(fp, "F%s", codetype[cp->type]);
			if (i == BTYPE_FILL)
				fprintf(fp, ", %d", n);
			fprintf(fp, ")\n");
		}
		if (i == BTYPE_INSERT) {
			set1field("INSERT_ACTION", tp->name, fp);
			for (cp = tp->chead; cp != NULL; cp = cp->next) {
				if (cp->flags & FLAG_AUTOINC)
					set1field("INSERT_SETID", cp->name, fp);
			}
		}
		fprintf(fp, "%s_EPILOG(`%s')\n", basetype[i], tp->name);
	}
	for (cp = tp->chead; cp != NULL; cp = cp->next) {
		if (cp->dfname != NULL) {
			fprintf(fp, "DELETE_PROLOG(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->dfname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0),", cp->name);
			fprintf(fp, "`%s',0)\n", cp->name);
			fprintf(fp, "DELETE_ELEMENT(`%s',", cp->name);
			fprintf(fp, "F%s)\n", codetype[cp->type]);
			set1field("DELETE_ACTION", tp->name, fp);
			set1field("DELETE_EPILOG", tp->name, fp);
		}
		if (cp->sfname != NULL) {
			fprintf(fp, "SEARCH_PROLOG(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->sfname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0),", cp->name);
			fprintf(fp, "`%s',0)\n", cp->name);
			fprintf(fp, "SEARCH_ELEMENT(`%s',", cp->name);
			fprintf(fp, "F%s)\n", codetype[cp->type]);
			set1field("SEARCH_ACTION", tp->name, fp);
			set1field("SEARCH_EPILOG", tp->name, fp);
		}
		if (cp->ufname != NULL) {
			fprintf(fp, "UPDATE_PROLOG(`%s',", tp->name);
			fprintf(fp, "`%s',", cp->ufname);
			fprintf(fp, "S%s(", codetype[cp->type]);
			fprintf(fp, "`%s',0),", cp->name);
			fprintf(fp, "`%s',0)\n", cp->name);
			fprintf(fp, "UPDATE_ELEMENT(`%s',", cp->name);
			fprintf(fp, "F%s)\n", codetype[cp->type]);
			set1field("UPDATE_ACTION", tp->name, fp);
			set1field("UPDATE_EPILOG", tp->name, fp);
		}
	}
	if (tp->flags & FLAG_DUMP) {
		fprintf(fp, "DUMP_PROLOG(`%s',`db_dump%s')\n", tp->name, tp->name);
		for (cp = tp->chead; cp != NULL; cp = cp->next) {
			fprintf(fp, "DUMP_ELEMENT(`%s', ", cp->name);
			fprintf(fp, "F%s)\n", codetype[cp->type]);
		}
		fprintf(fp, "DUMP_EPILOG(`%s')\n", tp->name);
	}
}

/*
 *
 */
void
genepilog(FILE *fp)
{
	/*
	 * XXX - don't use M4 when generating SQL (for now!).
	 */
	if (active->cdtype == CDT_DBASE)
		return;
	fprintf(fp, "FILE_EPILOG\n");
}
